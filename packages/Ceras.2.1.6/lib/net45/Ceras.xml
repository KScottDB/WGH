<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ceras</name>
    </assembly>
    <members>
        <member name="T:Ceras.Ignore">
            <summary>
            Add this to a field or property to force Ceras to ignore it.
            Check out the tutorial to see in what order attributes, the ShouldSerialize callback and other settings are evaluated.
            </summary>
        </member>
        <member name="T:Ceras.Include">
            <summary>
            Add this to a field or property to force Ceras to include it.
            Check out the tutorial to see in what order attributes, the ShouldSerialize callback and other settings are evaluated.
            </summary>
        </member>
        <member name="T:Ceras.SerializationOverride">
            <summary>
            Read the descriptions of the individual entries.
            </summary>
        </member>
        <member name="F:Ceras.SerializationOverride.NoOverride">
            <summary>
            When you return 'NoOverride' Ceras will continue normally, which is checking the member-attributes, class attributes, etc... check out the tutorial to see how Ceras decides what members are included in detail.
            </summary>
        </member>
        <member name="F:Ceras.SerializationOverride.ForceInclude">
            <summary>
            ForceInclude will completely skip all other checks and include the member. Be careful that you don't accidentally include hidden/compiler generated fields if you have turned 'SkipCompilerGeneratedFields' off.
            </summary>
        </member>
        <member name="F:Ceras.SerializationOverride.ForceSkip">
            <summary>
            Forces Ceras to ignore the field or property completely.
            </summary>
        </member>
        <member name="T:Ceras.MemberConfig">
            <summary>
            Configure what members to include by default in this type, you can also add [Ignore] and [Include] to individual members as well to override the member config.
            </summary>
        </member>
        <member name="T:Ceras.ReadonlyConfig">
            <summary>
            Use this to override global or class-level settings for a single field or property.
            </summary>
        </member>
        <member name="T:Ceras.TargetMember">
            <summary>
            What members should be serialized and deserialized
            </summary>
        </member>
        <member name="F:Ceras.TargetMember.PublicFields">
            <summary>
            Include all public fields, pretty obvious
            </summary>
        </member>
        <member name="F:Ceras.TargetMember.PrivateFields">
            <summary>
            Include private fields except for hidden compiler-generated fields (like backing fields for readonly-properties, enumerator state-machines, ...)
            </summary>
        </member>
        <member name="F:Ceras.TargetMember.PublicProperties">
            <summary>
            Only properties marked with the "public" keyword. So properties marked as internal/protected/private are not included
            </summary>
        </member>
        <member name="F:Ceras.TargetMember.PrivateProperties">
            <summary>
            Private properties are all properties that have "internal", "private", or "protected" as their visibility
            </summary>
        </member>
        <member name="T:Ceras.PreviousNameAttribute">
            <summary>
            Add this to a member if you have changed the type and you're using the VersionTolerance feature.
            Ceras will use this to map old field names to the new one.
            You can also use this to simply override what name is used to serialize the member, so as long as the attribute is around and does not change you can freely rename the member itself; this can be used to make the resulting serialized data smaller.
            </summary>
        </member>
        <member name="T:Ceras.CerasSerializer">
            <summary>
            <para>Ceras serializes any object to a byte-array and back.</para>
            <para>Want more features? Or something not working right?</para>
            <para>-> Then go here: https://github.com/rikimaru0345/Ceras </para>
            </summary>
        </member>
        <member name="P:Ceras.CerasSerializer.ProtocolChecksum">
            <summary>
            <para>The state-checksum of the serializer.</para>
            <para>Many configuration settings and all KnownTypes contribute to the checksum.</para>
            <para>Useful for networking scenarios, so when connecting you can ensure client and server are using the same settings and KnownTypes.</para>
            <para>Keep in mind that many things like <see cref="P:Ceras.SerializerConfig.ShouldSerializeMember"/> obviously cannot contribute to the checksum, but are still able to influence the serialization (and thus break network interoperability even when the checksum matches)</para>
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.#ctor(Ceras.SerializerConfig)">
            <summary>
            Creates a new CerasSerializer, be sure to check out the tutorial.
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.Serialize``1(``0)">
            <summary>!! Only use this method for testing !!
            <para>This method is pretty inefficient because it has to allocate an array for you and later resize it!</para>
            <para>For much better performance use <see cref="M:Ceras.CerasSerializer.Serialize``1(``0,System.Byte[]@,System.Int32)"/> instead.</para>
            <para>Take a quick look at the first step of the tutorial (it's on GitHub) if you are not sure how.</para>
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.Serialize``1(``0,System.Byte[]@,System.Int32)">
            <summary>
            Use this overload whenever you can. The intention is that you reuse the serialization buffer so the serializer only has to resize/reallocate a newer (larger) one if there really is not enough space; instead of allocating an array for every Serialize() call, this lets you avoid GC-pressure.
            You *can* pass in null for 'targetByteArray' and let the serializer allocate one for you.
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.Deserialize``1(System.Byte[])">
            <summary>
            Convenience method that will most likely allocate a T to return (using 'new T()'). Unless the data says the object really is null, in that case no instance of T is allocated.
            It would be smart to not use this method and instead use another overload. 
            That way the deserializer will set/populate the object you've provided. Obviously this only works if you can overwrite/reuse objects like this! (which, depending on what you're doing, might not be possible at all)
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.Deserialize``1(``0@,System.Byte[])">
            <summary>
            Deserializes an object from previously serialized data.
            <para>You can put in anything for the <paramref name="value"/>, and if the object in the data matches, Ceras will populate your existing object (overwrite its fields, clear/refill the collections, ...)</para>
            <para>Keep in mind that the config settings used for serialization must match exactly (should be obvious tho)</para>
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.Deserialize``1(``0@,System.Byte[],System.Int32@,System.Int32)">
            <summary>
            The most advanced deserialize method.
            <para>Again, you can put in an existing object to populate (or a variable that's currently null, in which case Ceras creates an object for you)</para>
            <para>In this version you can put in the offset as well, telling Ceras where to start reading from inside the buffer.</para>
            <para>After the method is done, the offset will be where Ceras has stopped reading.</para>
            <para>If you pass in a value >0 for <paramref name="expectedReadLength"/> then Ceras will check how many bytes it has read (only rarely useful)</para>
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.PeekType(System.Byte[])">
            <summary>
            Allows you to "peek" the object the data contains without having to fully deserialize the whole object.
            <para>Only works for data that was saved without version tolerance (maybe that'll be supported eventually, if someone requests it)</para>
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.GetFormatter``1">
            <summary>
            This is a shortcut to the <see cref="M:Ceras.CerasSerializer.GetReferenceFormatter(System.Type)"/> method
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.GetReferenceFormatter(System.Type)">
            <summary>
            Returns one of Ceras' internal formatters for some type.
            It automatically returns the right one for whatever type is passed in.
            </summary>
        </member>
        <member name="M:Ceras.CerasSerializer.GetSpecificFormatter(System.Type)">
            <summary>
            Similar to <see cref="M:Ceras.CerasSerializer.GetReferenceFormatter(System.Type)"/> it returns a formatter, but one that is not wrapped in a <see cref="T:Ceras.Formatters.ReferenceFormatter`1"/>.
            <para>You probably always want to use <see cref="M:Ceras.CerasSerializer.GetReferenceFormatter(System.Type)"/>, and only use this method instead when you are 100% certain you have emulated everything that <see cref="T:Ceras.Formatters.ReferenceFormatter`1"/> does for you.</para>
            <para>Internally Ceras uses this to </para>
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.PersistTypeCache">
            <summary>
            Determines whether to keep Type-To-Id maps after serialization/deserialization.
            This is ***ONLY*** intended for networking, where the deserializer keeps the state as well, and all serialized data is ephemeral (not saved to anywhere)
            This will likely save a huge amount of memory and cpu cycles over the lifespan of a network-session, because it will serialize type-information only once.
            
            If the serializer is used as a network protocol serializer, this option should definitely be turned on!
            Don't use this when serializing to anything persistent (files, database, ...) as you cannot deserialize any data if the deserializer type-cache is not in **EXACTLY**
            the same configuration as it (unless you really know exactly what you're doing)
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.PersistObjectCache">
            <summary>
            Same as PersistTypeCache, but if turned on, all other objects will get cached as well.
            Pretty interesting for networking as objects that have previously been sent to the other side will
            be serialized as a very short ID when they are encountered again (the other sides deserializer will keep the objects in memory as well).
            It is strongly suggested that you either completely clear, or manually remove objects from the object cache when an object is no longer used,
            as this frees up ID-space (making the connection more efficient) and also allows objects to be garbage collected.
            That means if you don't manage (clear/remove) the object cache explicitly, you'll eventually get an OutOfMemoryException.
            (Again, ONLY for networking purposes as serializer and deserializer have to stay in perfect sync!)
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.ObjectFactoryMethod">
            <summary>
            Whenever Ceras needs to create a new object it will use the factory method (if you have provided one)
            The primary intended use for this is object pooling; for example when receiving network messages you obviously don't want to 'new()' a new packet every time a message arrives, instead you want to take them from a pool. When doing so, you should of course also provide a 'DiscardObjectMethod' so Ceras can give you objects back when they are not used anymore (happens when you use the ref-version of deserialize to overwrite existing objects).
            Another thing this can be used for is when you have a type that only has a static Create method instead of a parameterless constructor.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.DiscardObjectMethod">
            <summary>
            Set this to a function you provide. Ceras will call it when an object instance is no longer needed.
            For example you want to populate an existing object with data, and one of the fields already has a value (a left-over from the last time it was used),
            but the current data says that the field should be 'null'. That's when Ceras will call this this method so you can recycle the object (maybe return it to your object-pool)
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.SkipCompilerGeneratedFields">
            <summary>
            !! Important:
            You may believe you know what you're doing when including things compiler-generated fields, but there are tons of other problems you most likely didn't even realize unless you've read the github issue here: https://github.com/rikimaru0345/Ceras/issues/11. 
            
            Hint: You may end up including all sorts of stuff like enumerator statemachines, delegates, remanants of 'dynamic' objects, ...
            So here's your warning: Don't set this to false unless you know what you're doing.
            
            This defaults to true, which means that fields marked as [CompilerGenerated] are skipped without asking your 'ShouldSerializeMember' function (if you have set one).
            For 99% of all use cases this is exactly what you want. For more information read the 'readonly properties' section in the tutorial.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.ShouldSerializeMember">
            <summary>
            This is the very first thing that ceras uses to determine whether or not to serialize something. While not the most comfortable, it is useful because it is called for types you don't control (types from other libraries where you don't have the source code...).
            Important: Compiler generated fields are always skipped by default, for more information about that see the 'readonly properties' section in the tutorial where all of this is explained in detail.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.ExternalObjectResolver">
            <summary>
            If your object implement IExternalRootObject they are written as their external ID, so at deserialization-time you need to provide a resolver for Ceras so it can get back the Objects from their IDs.
            When would you use this?
            There's a lot of really interesting use cases for this, be sure to read the tutorial section 'GameDatabase' even if you're not making a game.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.TypeBinder">
            <summary>
            A TypeBinder does two very simple things: 1. it produces a name of a given 'Type', and 2. it finds a 'Type' when given that name.
            The default type binder (NaiveTypeBinder) simply uses '.FullName', but there are many cases where you would want to mess around with that.
            For example if your objects have very long full-names (many long namespaces), then you could definitely improve performance and output size of your serialized binary by (for example) shortening the namespaces. See the readme on github for more information.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.OnExternalObject">
            <summary>
            If one of the objects in the graph implements IExternalRootObject, Ceras will only write its ID and then call this function. 
            That means this external object for which only the ID was written, was not serialized itself. But often you want to sort of "collect" all the elements
            that belong into an object-graph and save them at the same time. That's when you'd use this callback. 
            Make sure to read the 'GameDatabase' example in the tutorial even if you're not making a game.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.OnResolveFormatter">
            <summary>
            If you want to provide your own formatter resolver, use this.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.KnownTypes">
            <summary>
            Add all the types you want to serialize to this collection.
            When Ceras serializes your objects, and the object field is not exactly matching (for example a base type) then ceras obviously has to write the type.
            Even though Ceras is optimized so it only writes the type once, that is sometimes unacceptable (networking for example).
            So if you add types here, Ceras can *always* use a pre-calculated typeID directly. 
            See the tutorial for more information.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.SealTypesWhenUsingKnownTypes">
            <summary>
            Defaults to true to protect against unintended usage. 
            Which means that when KnownTypes has any entries the TypeFormatter will be sealed to prevent adding more types.
            The idea is that when someone uses KnownTypes, they have a fixed list of types
            they want to serialize (to minimize overhead from serializing type names initially), which is usually done in networking scenarios;
            While working on a project you might add more types or add new fields or things like that, and a common mistake is accidentally adding a new type (or even whole graph!)
            to the object graph that was not intended; which is obviously extremely problematic (super risky if sensitive 
            stuff gets suddenly dragged into the serialization; or might even just crash when encountering types that can't even be serialized correctly; ...).
            Don't disable this unless you know what you're doing.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.VersionTolerance">
            <summary>
            Sometimes you want to persist objects even while they evolve (fields being added, removed, renamed).
            IMPORTANT: Type changes are not yet supported, and there are other things to be aware of, so check out the tutorial for more information (and a way to deal with changing types)
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.GenerateChecksum">
            <summary>
            If true, the serializer will generate dynamic object formatters early (in the constructor).
            This can obviously only work if you use sealed KnownTypes (meaning you put all your types into KnownTypes and then have the serializer seal it at construction time).
            Then it is assured that no new types will be added dynamically, which in turn means that the "protocol hash" will not change.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.EmbedChecksum">
            <summary>
            Embed protocol/serializer checksum at the start of any serialized data, and read it back when deserializing to make sure we're not reading incompatible data on accident
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.DefaultTargets">
            <summary>
            If all the other things (ShouldSerializeMember and all the attributes) yield no result, then this setting is used to determine if a member should be included.
            </summary>
        </member>
        <member name="P:Ceras.SerializerConfig.ReadonlyFieldHandling">
            <summary>
            Explaining this setting here would take too much space, check out the tutorial section for details.
            </summary>
        </member>
        <member name="T:Ceras.ReadonlyFieldHandling">
            <summary>
            Options how Ceras handles readonly fields. Check the description of each entry.
            </summary>
        </member>
        <member name="F:Ceras.ReadonlyFieldHandling.Off">
            <summary>
            By default ceras will ignore readonly fields.
            </summary>
        </member>
        <member name="F:Ceras.ReadonlyFieldHandling.Members">
            <summary>
            Handle readonly fields the safe way: By serializing and deserializing the inner members of a readonly field. If the field element itself is not as expected, this will throw an exception.
            </summary>
        </member>
        <member name="F:Ceras.ReadonlyFieldHandling.ForcedOverwrite">
            <summary>
            Same as 'Members', but instead of throwing an exception, Ceras will fix the mismatch by force (using reflection). To know what that means and when to use it, check out the tutorial section about readonly handling.
            </summary>
        </member>
        <member name="T:Ceras.ProtocolChecksum">
            <summary>
            A class that the serializer uses to keep track of the "checksum" of its internal state.
            Why? What for?
            Since we have absolutely no "backwards compatibility" or "versioning" in the binary data,
            the serializer/deserializer has to be exactly the same, meaning the same classes with the same type-codes
            in exactly the same order. Each class must have the same fields in the same order, with the same types and attributes.
            To make all this easier, the serializer simply puts all the information into this class.
            - constructs the dynamic serializers directly when the serializer gets created
            - optionally emits a checksum into the binary (just 1 int)
            </summary>
        </member>
        <member name="P:Ceras.Helpers.IPool`1.Capacity">
            <summary>
            How many objects the pool has in total.
            The sum of the objects that are not used and still in the pool, plus the objects that are currently in use (rented out)
            </summary>
        </member>
        <member name="P:Ceras.Helpers.IPool`1.ObjectsAvailableInPool">
            <summary>
            The number of objects that the pool has still available
            </summary>
        </member>
    </members>
</doc>
